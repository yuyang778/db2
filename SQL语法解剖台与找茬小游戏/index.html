<!DOCTYPE html>
<html lang="zh-CN">
    <script src="page-protector.js"></script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL语法解剖台与找茬小游戏</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #3498db;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .panel {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 20px;
            flex: 1;
            min-width: 300px;
        }
        
        .sql-input {
            width: 100%;
            height: 120px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            margin-bottom: 15px;
            resize: vertical;
        }
        
        .button {
            padding: 10px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .button:hover {
            background-color: #2980b9;
        }
        
        .button.secondary {
            background-color: #95a5a6;
        }
        
        .button.secondary:hover {
            background-color: #7f8c8d;
        }
        
        .execution-steps {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background-color: #f9f9f9;
        }
        
        .step {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        
        .step.active {
            display: block;
            background-color: #e3f2fd;
            border-left: 4px solid #3498db;
        }
        
        .step-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #3498db;
        }
        
        .step-content {
            font-family: monospace;
            white-space: pre-wrap;
            background-color: white;
            padding: 8px;
            border-radius: 3px;
            overflow-x: auto;
        }
        
        .highlight {
            background-color: #fff9c4;
            padding: 2px;
            border-radius: 2px;
        }
        
        .error-highlight {
            background-color: #ffcdd2;
            text-decoration: underline wavy red;
        }
        
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .game-container {
            margin-top: 20px;
        }
        
        .game-question {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .game-sql {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            position: relative;
            margin-bottom: 15px;
        }
        
        .game-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .game-option {
            padding: 10px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .game-option:hover {
            background-color: #f0f0f0;
        }
        
        .game-option.selected {
            background-color: #e3f2fd;
            border-color: #3498db;
        }
        
        .game-option.correct {
            background-color: #c8e6c9;
            border-color: #2ecc71;
        }
        
        .game-option.incorrect {
            background-color: #ffcdd2;
            border-color: #e74c3c;
        }
        
        .game-feedback {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
        }
        
        .game-feedback.correct {
            background-color: #c8e6c9;
            border-left: 4px solid #2ecc71;
            display: block;
        }
        
        .game-feedback.incorrect {
            background-color: #ffcdd2;
            border-left: 4px solid #e74c3c;
            display: block;
        }
        
        .game-next {
            display: none;
        }
        
        .game-next.show {
            display: inline-block;
        }
        
        .error-types {
            margin-top: 20px;
        }
        
        .error-type {
            margin-bottom: 15px;
            padding: 10px;
            background-color: white;
            border-left: 4px solid #e74c3c;
            border-radius: 3px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .error-title {
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        th {
            background-color: #3498db;
            color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .sample-data {
            margin-top: 20px;
            display: none;
        }
        
        .sample-data.show {
            display: block;
        }
    </style>
</head>
<body>
    <h1>SQL语法解剖台与找茬小游戏</h1>
    
    <div class="container">
        <div class="panel">
            <h2>SQL语法解剖台</h2>
            <p>输入SQL查询语句，查看分步执行过程和结果：</p>
            
            <textarea class="sql-input" id="sql-input" placeholder="例如: SELECT name, age FROM Students WHERE age > 20 ORDER BY age DESC;">SELECT s.name, g.grade 
FROM Students s 
JOIN GRADE g ON s.sid = g.sid 
WHERE g.cid = 'C001' 
ORDER BY g.grade DESC;</textarea>
            
            <div>
                <button class="button" id="parse-btn">解析SQL</button>
                <button class="button secondary" id="sample1">示例1: 简单查询</button>
                <button class="button secondary" id="sample2">示例2: 多表连接</button>
                <button class="button secondary" id="sample3">示例3: 聚合查询</button>
            </div>
            
            <div class="execution-steps">
                <div class="step" id="step-from">
                    <div class="step-title">1. FROM 子句执行</div>
                    <div class="step-content" id="step-from-content"></div>
                </div>
                
                <div class="step" id="step-join">
                    <div class="step-title">2. JOIN 子句执行</div>
                    <div class="step-content" id="step-join-content"></div>
                </div>
                
                <div class="step" id="step-where">
                    <div class="step-title">3. WHERE 子句执行</div>
                    <div class="step-content" id="step-where-content"></div>
                </div>
                
                <div class="step" id="step-groupby">
                    <div class="step-title">4. GROUP BY 子句执行</div>
                    <div class="step-content" id="step-groupby-content"></div>
                </div>
                
                <div class="step" id="step-having">
                    <div class="step-title">5. HAVING 子句执行</div>
                    <div class="step-content" id="step-having-content"></div>
                </div>
                
                <div class="step" id="step-select">
                    <div class="step-title">6. SELECT 子句执行</div>
                    <div class="step-content" id="step-select-content"></div>
                </div>
                
                <div class="step" id="step-orderby">
                    <div class="step-title">7. ORDER BY 子句执行</div>
                    <div class="step-content" id="step-orderby-content"></div>
                </div>
                
                <div class="step" id="step-limit">
                    <div class="step-title">8. TOP子句执行</div>
                    <div class="step-content" id="step-limit-content"></div>
                </div>
                
                <div class="navigation">
                    <button class="button secondary" id="prev-step" disabled>上一步</button>
                    <button class="button secondary" id="next-step" disabled>下一步</button>
                </div>
            </div>
            
            <div class="sample-data" id="sample-data">
                <h3>示例数据库表数据</h3>
                <div id="tables-container"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>SQL找茬小游戏</h2>
            <p>找出以下SQL语句中的错误或不良实践：</p>
            
            <div class="game-container" id="game-container">
                <div class="game-question" id="game-question"></div>
                <div class="game-sql" id="game-sql"></div>
                
                <div class="game-options" id="game-options"></div>
                
                <div class="game-feedback" id="game-feedback"></div>
                
                <button class="button" id="check-answer">检查答案</button>
                <button class="button game-next" id="next-question">下一题</button>
            </div>
            
            <div class="error-types">
                <h3>常见SQL错误类型</h3>
                
                <div class="error-type">
                    <div class="error-title">1. GROUP BY 误用</div>
                    <p>SELECT列表中的非聚合列必须出现在GROUP BY子句中。</p>
                    <p><strong>错误示例：</strong> <code>SELECT department, name, AVG(salary) FROM Employees GROUP BY department;</code></p>
                </div>
                
                <div class="error-type">
                    <div class="error-title">2. HAVING 误用</div>
                    <p>HAVING用于过滤分组后的结果，WHERE用于过滤行。</p>
                    <p><strong>错误示例：</strong> <code>SELECT department, AVG(salary) FROM Employees HAVING salary > 5000 GROUP BY department;</code></p>
                </div>
                
                <div class="error-type">
                    <div class="error-title">3. JOIN 条件缺失</div>
                    <p>多表连接时缺少ON条件会导致笛卡尔积。</p>
                    <p><strong>错误示例：</strong> <code>SELECT * FROM Students JOIN grade;</code></p>
                </div>
                
                <div class="error-type">
                    <div class="error-title">4. 歧义列名</div>
                    <p>多表查询时，相同列名需要指定表名前缀。</p>
                    <p><strong>错误示例：</strong> <code>SELECT id, name FROM Students JOIN grade ON Students.id = grade.sid;</code></p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // 示例数据库
        const sampleDatabase = {
            Students: [
                { sid: "S001", name: "张三", age: 20, major: "计算机科学" },
                { sid: "S002", name: "李四", age: 21, major: "数学" },
                { sid: "S003", name: "王五", age: 19, major: "计算机科学" },
                { sid: "S004", name: "赵六", age: 22, major: "物理" },
                { sid: "S005", name: "钱七", age: 20, major: "数学" }
            ],
            Courses: [
                { cid: "C001", title: "数据库系统", credits: 4, department: "计算机科学" },
                { cid: "C002", title: "高等数学", credits: 5, department: "数学" },
                { cid: "C003", title: "量子力学", credits: 3, department: "物理" },
                { cid: "C004", title: "算法设计", credits: 4, department: "计算机科学" }
            ],
            Grade: [
                { sid: "S001", cid: "C001", grade: 85, semester: "2023春" },
                { sid: "S001", cid: "C002", grade: 90, semester: "2023春" },
                { sid: "S002", cid: "C002", grade: 78, semester: "2023春" },
                { sid: "S003", cid: "C001", grade: 92, semester: "2023春" },
                { sid: "S004", cid: "C003", grade: 88, semester: "2023春" },
                { sid: "S005", cid: "C002", grade: 95, semester: "2023春" }
            ],
            Employees: [
                { id: "E001", name: "张经理", salary: 8000, department: "销售" },
                { id: "E002", name: "李主管", salary: 6000, department: "销售" },
                { id: "E003", name: "王工程师", salary: 7500, department: "技术" },
                { id: "E004", name: "赵会计", salary: 5500, department: "财务" },
                { id: "E005", name: "钱设计师", salary: 6500, department: "设计" }
            ]
        };
        
        // 找茬游戏题库
        const gameQuestions = [
            {
                question: "找出以下SQL语句中的错误:",
                sql: "SELECT department, name, AVG(salary)\nFROM Employees\nGROUP BY department;",
                options: [
                    "GROUP BY子句缺少name列",
                    "HAVING子句缺失",
                    "表名拼写错误",
                    "没有错误"
                ],
                correct: 0,
                feedback: "错误: SELECT列表中的非聚合列(name)必须出现在GROUP BY子句中。\n正确写法: SELECT department, name, AVG(salary) FROM Employees GROUP BY department, name;"
            },
            {
                question: "以下SQL语句有什么问题?",
                sql: "SELECT department, AVG(salary)\nFROM Employees\nHAVING salary > 5000\nGROUP BY department;",
                options: [
                    "HAVING应该在GROUP BY之后",
                    "HAVING不能用于非聚合列",
                    "GROUP BY和HAVING顺序错误",
                    "以上都是"
                ],
                correct: 3,
                feedback: "错误: 1) HAVING用于过滤分组结果，不能直接过滤行(salary > 5000)\n2) HAVING应该在GROUP BY之后\n正确写法: SELECT department, AVG(salary) FROM Employees GROUP BY department HAVING AVG(salary) > 5000;"
            },
            {
                question: "以下SQL语句会导致什么问题?",
                sql: "SELECT *\nFROM Students\nJOIN grade;",
                options: [
                    "缺少JOIN条件，会产生笛卡尔积",
                    "语法错误",
                    "性能问题",
                    "1和3都是"
                ],
                correct: 3,
                feedback: "错误: 缺少ON条件会导致笛卡尔积(两表所有行的组合)，产生大量数据\n正确写法: SELECT * FROM Students JOIN grade ON Students.sid = grade.sid;"
            },
            {
                question: "以下SQL语句有什么潜在问题?",
                sql: "SELECT id, name\nFROM Students\nJOIN grade\nON Students.id = grade.sid;",
                options: [
                    "列名歧义(id可能来自两个表)",
                    "JOIN条件错误",
                    "缺少WHERE子句",
                    "没有潜在问题"
                ],
                correct: 0,
                feedback: "问题: 1) 列名id不明确，应该指定表名前缀\n2) Students表主键应为sid而非id\n正确写法: SELECT Students.sid, Students.name FROM Students JOIN grade ON Students.sid = grade.sid;"
            }
        ];
        
        // 语法解剖台功能
        let currentStep = 0;
        const steps = ['step-from', 'step-join', 'step-where', 'step-groupby', 'step-having', 'step-select', 'step-orderby', 'step-limit'];
        let currentSQL = '';
        let executionResults = {};
        
        document.getElementById('parse-btn').addEventListener('click', parseSQL);
        document.getElementById('prev-step').addEventListener('click', prevStep);
        document.getElementById('next-step').addEventListener('click', nextStep);
        document.getElementById('sample1').addEventListener('click', () => loadSample(0));
        document.getElementById('sample2').addEventListener('click', () => loadSample(1));
        document.getElementById('sample3').addEventListener('click', () => loadSample(2));
        
        // 找茬游戏功能
        let currentQuestion = 0;
        let selectedOption = null;
        
        document.querySelectorAll('.game-option').forEach(option => {
            option.addEventListener('click', selectOption);
        });
        
        document.getElementById('check-answer').addEventListener('click', checkAnswer);
        document.getElementById('next-question').addEventListener('click', nextQuestion);
        
        initGame();
        
        // 解析SQL并展示执行步骤
        function parseSQL() {
            const sqlInput = document.getElementById('sql-input').value.trim();
            if (!sqlInput) {
                alert('请输入SQL查询语句');
                return;
            }
            
            currentSQL = sqlInput;
            document.getElementById('sample-data').classList.add('show');
            showSampleData();
            
            try {
                executionResults = simulateSQLExecution(sqlInput);
                currentStep = 0;
                updateStepDisplay();
                document.getElementById('prev-step').disabled = true;
                document.getElementById('next-step').disabled = false;
            } catch (e) {
                alert('SQL解析错误: ' + e.message);
            }
        }
        
        // 模拟SQL执行过程
        function simulateSQLExecution(sql) {
            // SQL Server语法解析
            const results = {};
            const sqlLower = sql.toLowerCase();
            
            // 处理TOP子句
            let topLimit = null;
            const topMatch = sqlLower.match(/select\s+top\s+(\d+)/i);
            if (topMatch) {
                topLimit = parseInt(topMatch[1]);
            }
            
            // FROM 子句
            const fromMatch = sqlLower.match(/from\s+([^\s,)(;]+)/);
            if (!fromMatch) {
                throw new Error('缺少FROM子句');
            }
            
            let fromTable = fromMatch[1];
            // 不区分大小写查找表
            const fromTableKey = Object.keys(sampleDatabase).find(
                key => key.toLowerCase() === fromTable.toLowerCase()
            );
            
            if (fromTableKey) {
                results.from = [...sampleDatabase[fromTableKey]];
            } else {
                throw new Error(`表 ${fromTable} 不存在`);
            }
            
            // JOIN 子句
            if (sqlLower.includes('join')) {
                let currentFrom = results.from;
                // 存储表别名映射关系
                const tableAliases = {};
                
                // 从FROM子句提取主表及其别名
                const fromAliasMatch = sqlLower.match(/from\s+(\w+)(?:\s+as)?\s+(\w+)/i) || 
                                       sqlLower.match(/from\s+(\w+)(?:\s+)(\w+)/i);
                                       
                if (fromAliasMatch) {
                    const mainTable = fromAliasMatch[1];
                    const mainAlias = fromAliasMatch[2];
                    tableAliases[mainAlias.toLowerCase()] = mainTable.toLowerCase();
                    console.log(`检测到主表别名: ${mainAlias} -> ${mainTable}`);
                }
                
                // 分割JOIN子句
                const joinSegments = sql.split(/\s+join\s+/i);
                
                // 第一部分是FROM子句，从第二部分开始处理JOIN
                for (let i = 1; i < joinSegments.length; i++) {
                    const segment = joinSegments[i];
                    
                    // 匹配表名、别名和ON条件
                    const joinTableMatch = segment.match(/(\w+)(?:\s+as)?\s+(\w+)\s+on\s+/i) || 
                                          segment.match(/(\w+)(?:\s+)(\w+)\s+on\s+/i);
                                          
                    if (!joinTableMatch) {
                        console.error('无法解析JOIN表名和别名:', segment);
                        throw new Error('JOIN子句格式错误，无法识别表名和别名');
                    }
                    
                    const joinTable = joinTableMatch[1];
                    const joinAlias = joinTableMatch[2];
                    
                    // 记录别名映射
                    tableAliases[joinAlias.toLowerCase()] = joinTable.toLowerCase();
                    console.log(`检测到JOIN表别名: ${joinAlias} -> ${joinTable}`);
                    
                    // 提取ON条件
                    const onConditionMatch = segment.match(/on\s+(.+?)(?=\s+join|\s+where|\s+group|\s+having|\s+order|\s+limit|;|$)/i);
                    if (!onConditionMatch) {
                        throw new Error('JOIN子句缺少ON条件');
                    }
                    
                    const joinCondition = onConditionMatch[1];
                    console.log(`JOIN条件: ${joinCondition}`);
                    
                    // 在sampleDatabase中查找真实表名
                    const joinTableKey = Object.keys(sampleDatabase).find(
                        key => key.toLowerCase() === joinTable.toLowerCase()
                    );
                    
                    if (!joinTableKey) {
                        throw new Error(`表 ${joinTable} 不存在`);
                    }
                    
                    // 执行JOIN
                    try {
                        currentFrom = performJoin(currentFrom, sampleDatabase[joinTableKey], joinCondition);
                        
                        // 存储JOIN信息
                        results.join = {
                            table: joinTableKey,
                            alias: joinAlias,
                            condition: joinCondition,
                            result: currentFrom
                        };
                    } catch (e) {
                        console.error('JOIN执行错误:', e);
                        throw new Error(`执行JOIN操作失败: ${e.message}`);
                    }
                }
                
                // 保存表别名映射到结果中
                results.tableAliases = tableAliases;
                console.log('最终表别名映射:', tableAliases);
            }
            
            // WHERE 子句
            if (sqlLower.includes('where')) {
                const whereMatch = sql.match(/where\s+(.+?)(?=\s+group|\s+having|\s+order|\s+limit|;|$)/i);
                if (whereMatch) {
                    const whereCondition = whereMatch[1];
                    const data = results.join ? results.join.result : results.from;
                    
                    try {
                        results.where = {
                            condition: whereCondition,
                            result: filterData(data, whereCondition)
                        };
                    } catch (e) {
                        throw new Error('WHERE条件解析错误: ' + e.message);
                    }
                }
            }
            
            // GROUP BY 子句
            if (sqlLower.includes('group by')) {
                const groupMatch = sql.match(/group by\s+(.+?)(?=\s+having|\s+order|\s+limit|;|$)/i);
                if (groupMatch) {
                    const groupColumns = groupMatch[1].split(',').map(col => col.trim());
                    const data = results.where ? results.where.result : 
                                results.join ? results.join.result : results.from;
                    
                    results.groupby = {
                        columns: groupColumns,
                        result: groupData(data, groupColumns)
                    };
                }
            }
            
            // HAVING 子句
            if (sqlLower.includes('having')) {
                const havingMatch = sql.match(/having\s+(.+?)(?=\s+order|\s+limit|;|$)/i);
                if (havingMatch) {
                    if (!results.groupby) {
                        throw new Error('HAVING子句需要GROUP BY子句');
                    }
                    
                    const havingCondition = havingMatch[1];
                    try {
                        results.having = {
                            condition: havingCondition,
                            result: filterData(results.groupby.result, havingCondition, true)
                        };
                    } catch (e) {
                        throw new Error('HAVING条件解析错误: ' + e.message);
                    }
                }
            }
            
            // SELECT 子句
            const selectMatch = sql.match(/select\s+(.+?)\s+from/i);
            if (selectMatch) {
                const selectColumns = selectMatch[1].split(',').map(col => col.trim());
                let data;
                
                if (results.having) {
                    data = results.having.result;
                } else if (results.groupby) {
                    data = results.groupby.result;
                } else if (results.where) {
                    data = results.where.result;
                } else if (results.join) {
                    data = results.join.result;
                } else {
                    data = results.from;
                }
                
                results.select = {
                    columns: selectColumns,
                    result: selectColumns.includes('*') ? data : projectData(data, selectColumns)
                };
            }
            
            // ORDER BY 子句
            if (sqlLower.includes('order by')) {
                const orderMatch = sql.match(/order by\s+(.+?)(?=\s+limit|;)/i);
                if (orderMatch) {
                    const orderColumns = orderMatch[1].split(',').map(col => {
                        const parts = col.trim().split(/\s+/);
                        return {
                            column: parts[0],
                            direction: parts[1] ? parts[1].toLowerCase() : 'asc'
                        };
                    });
                    
                    const data = results.select ? results.select.result : 
                                results.having ? results.having.result :
                                results.groupby ? results.groupby.result :
                                results.where ? results.where.result :
                                results.join ? results.join.result : results.from;
                    
                    results.orderby = {
                        columns: orderColumns,
                        result: orderData(data, orderColumns)
                    };
                }
            }
            
            // 替换使用LIMIT为TOP
            if (topLimit !== null) {
                results.limit = {
                    limit: topLimit,
                    result: results.orderby ? results.orderby.result.slice(0, topLimit) :
                            results.select ? results.select.result.slice(0, topLimit) :
                            results.having ? results.having.result.slice(0, topLimit) :
                            results.groupby ? results.groupby.result.slice(0, topLimit) :
                            results.where ? results.where.result.slice(0, topLimit) :
                            results.join ? results.join.result.slice(0, topLimit) : 
                            results.from.slice(0, topLimit)
                };
            } else if (sqlLower.includes('top')) {
                const limitMatch = sqlLower.match(/top\s+(\d+)/i);
                if (limitMatch) {
                    const limit = parseInt(limitMatch[1]);
                    const data = results.orderby ? results.orderby.result :
                                results.select ? results.select.result :
                                results.having ? results.having.result :
                                results.groupby ? results.groupby.result :
                                results.where ? results.where.result :
                                results.join ? results.join.result : results.from;
                    
                    results.limit = {
                        limit: limit,
                        result: data.slice(0, limit)
                    };
                }
            }
            
            return results;
        }
        
        // 执行JOIN操作
        function performJoin(table1, table2, condition) {
            console.log('执行JOIN:', condition);
            console.log('左表数据样例:', table1.slice(0, 1));
            console.log('右表数据样例:', table2.slice(0, 1));
            
            // 解析JOIN条件 (支持表别名)
            const equalPos = condition.indexOf('=');
            if (equalPos === -1) {
                throw new Error('JOIN条件必须是等值连接');
            }
            
            const leftPart = condition.substring(0, equalPos).trim();
            const rightPart = condition.substring(equalPos + 1).trim();
            
            // 提取左右两边的列名
            const leftMatch = leftPart.match(/(\w+)\.(\w+)/);
            const rightMatch = rightPart.match(/(\w+)\.(\w+)/);
            
            if (!leftMatch || !rightMatch) {
                throw new Error('JOIN条件格式错误：' + condition);
            }
            
            const leftTableAlias = leftMatch[1];
            const leftColumn = leftMatch[2];
            const rightTableAlias = rightMatch[1]; 
            const rightColumn = rightMatch[2];
            
            console.log(`JOIN条件解析: ${leftTableAlias}.${leftColumn} = ${rightTableAlias}.${rightColumn}`);
            
            // 执行JOIN
            const result = [];
            table1.forEach(row1 => {
                table2.forEach(row2 => {
                    // 尝试匹配条件
                    if (row1[leftColumn] === row2[rightColumn]) {
                        // 合并记录，避免列名冲突
                        const joinedRow = { ...row1 };
                        // 添加右表的列
                        for (const key in row2) {
                            // 如果列名在左表中已存在且值不同，则添加前缀
                            if (key in joinedRow && row2[key] !== joinedRow[key]) {
                                joinedRow[`${rightTableAlias}_${key}`] = row2[key];
                            } else {
                                joinedRow[key] = row2[key];
                            }
                        }
                        result.push(joinedRow);
                    }
                });
            });
            
            console.log(`JOIN结果: ${result.length}条记录`);
            return result;
        }
        
        // 过滤数据
        function filterData(data, condition, isHaving = false) {
            // 简化的条件过滤
            try {
                if (isHaving) {
                    // 处理HAVING子句中的聚合函数
                    if (condition.toLowerCase().includes('count(*)')) {
                        // 计算每个分组的数量
                        const countData = [...data];
                        
                        // 提取操作符和值（如 > 1）
                        const match = condition.match(/COUNT\(\*\)\s*([><=!]+)\s*(\d+)/i);
                        if (!match) {
                            const countMatch = condition.match(/COUNT\s*\(\s*\*\s*\)\s*([><=!]+)\s*(\d+)/i);
                            if (!countMatch) {
                                throw new Error('不支持的HAVING条件格式');
                            }
                            return processCountCondition(countData, countMatch[1], parseInt(countMatch[2]));
                        }
                        
                        return processCountCondition(countData, match[1], parseInt(match[2]));
                    } else if (condition.toLowerCase().includes('avg(')) {
                        // 这里可以添加处理其他聚合函数的代码
                        throw new Error('暂不支持的聚合函数');
                    } else {
                        // 处理简单条件
                        const simpleCondition = condition.replace(/(\w+)\.(\w+)/g, '$2');
                        throw new Error('暂不支持的HAVING条件: ' + simpleCondition);
                    }
                } else {
                    // WHERE 子句的处理
                    // 输出调试信息
                    console.log('处理条件: ', condition);
                    
                    // 处理带有表别名的情况
                    let processedCondition = condition;
                    
                    // 检查是否有表别名 (例如 e.cid = 'C001')
                    if (condition.includes('.')) {
                        // 提取条件表达式的部分 (支持别名)
                        const condParts = condition.match(/([\w.]+)\s*([=<>!]+)\s*['"]?([^'"]+)['"]?/);
                        if (!condParts) {
                            throw new Error('不支持的WHERE条件格式: ' + condition);
                        }
                        
                        const [_, fieldWithAlias, operator, value] = condParts;
                        
                        // 处理可能带有表别名的字段
                        let field = fieldWithAlias;
                        if (fieldWithAlias.includes('.')) {
                            // 只获取列名部分，不关心表别名
                            field = fieldWithAlias.split('.')[1];
                        }
                        
                        // 去除值中可能的引号
                        const cleanValue = value.replace(/^['"]|['"]$/g, '');
                        console.log(`字段: ${field}, 操作符: ${operator}, 值: ${cleanValue}`);
                        
                        // 根据操作符过滤
                        return data.filter(row => {
                            const fieldValue = row[field];
                            
                            if (fieldValue === undefined) {
                                console.log(`找不到字段 ${field}, 行数据: `, row);
                                return false;
                            }
                            
                            // 尝试数值比较
                            if (!isNaN(fieldValue) && !isNaN(cleanValue)) {
                                const numValue = parseFloat(cleanValue);
                                const numFieldValue = parseFloat(fieldValue);
                                
                                switch(operator) {
                                    case '>': return numFieldValue > numValue;
                                    case '>=': return numFieldValue >= numValue;
                                    case '<': return numFieldValue < numValue;
                                    case '<=': return numFieldValue <= numValue;
                                    case '=': 
                                    case '==': return numFieldValue === numValue;
                                    case '!=': 
                                    case '<>': return numFieldValue !== numValue;
                                    default: return false;
                                }
                            } else {
                                // 字符串比较
                                switch(operator) {
                                    case '=': 
                                    case '==': return fieldValue === cleanValue;
                                    case '!=': 
                                    case '<>': return fieldValue !== cleanValue;
                                    default: return false; // 字符串不支持其他比较操作符
                                }
                            }
                        });
                    } else {
                        // 处理简单条件 (不带表别名)
                        // ... existing code for simple conditions ...
                        const condParts = condition.match(/([^\s]+)\s*([=<>!]+)\s*['"]?([^'"]+)['"]?/);
                        if (!condParts) {
                            throw new Error('不支持的WHERE条件格式: ' + condition);
                        }
                        
                        let [_, field, operator, value] = condParts;
                        // 处理表名前缀
                        field = field.includes('.') ? field.split('.')[1] : field;
                        
                        // 去除值中可能的引号
                        value = value.replace(/^['"]|['"]$/g, '');
                        
                        // 根据操作符过滤
                        return data.filter(row => {
                            const fieldValue = row[field];
                            
                            // 尝试数值比较
                            if (!isNaN(fieldValue) && !isNaN(value)) {
                                const numValue = parseFloat(value);
                                const numFieldValue = parseFloat(fieldValue);
                                
                                switch(operator) {
                                    case '>': return numFieldValue > numValue;
                                    case '>=': return numFieldValue >= numValue;
                                    case '<': return numFieldValue < numValue;
                                    case '<=': return numFieldValue <= numValue;
                                    case '=': 
                                    case '==': return numFieldValue === numValue;
                                    case '!=': 
                                    case '<>': return numFieldValue !== numValue;
                                    default: return false;
                                }
                            } else {
                                // 字符串比较
                                switch(operator) {
                                    case '=': 
                                    case '==': return fieldValue === value;
                                    case '!=': 
                                    case '<>': return fieldValue !== value;
                                    default: return false; // 字符串不支持其他比较操作符
                                }
                            }
                        });
                    }
                }
            } catch (e) {
                console.error('条件解析错误: ', e);
                throw new Error('无法解析条件: ' + condition);
            }
        }
        
        // 处理COUNT(*)条件的辅助函数
        function processCountCondition(countData, operator, value) {
            // 对每个分组计算记录数
            countData.forEach(row => {
                // 找出与当前分组匹配的所有原始记录
                const matchingRecords = [];
                // 获取原始数据（在分组之前的数据）
                const originalData = executionResults.where ? executionResults.where.result : 
                                   executionResults.join ? executionResults.join.result : 
                                   executionResults.from;
                
                // 比较字段，记录分组字段
                const groupFields = Object.keys(row).filter(k => !k.startsWith('__'));
                
                // 对原始数据进行计数
                originalData.forEach(origRow => {
                    let matches = true;
                    for (const field of groupFields) {
                        if (row[field] !== origRow[field]) {
                            matches = false;
                            break;
                        }
                    }
                    if (matches) {
                        matchingRecords.push(origRow);
                    }
                });
                
                // 设置count值
                row.__count = matchingRecords.length;
            });
            
            // 根据操作符过滤
            return countData.filter(row => {
                switch(operator) {
                    case '>': return row.__count > value;
                    case '>=': return row.__count >= value;
                    case '<': return row.__count < value;
                    case '<=': return row.__count <= value;
                    case '=': 
                    case '==': return row.__count === value;
                    case '!=': 
                    case '<>': return row.__count !== value;
                    default: return false;
                }
            });
        }
        
        // 分组数据
        function groupData(data, columns) {
            const groups = {};
            
            data.forEach(row => {
                const key = columns.map(col => row[col]).join('|');
                if (!groups[key]) {
                    groups[key] = { ...row };
                    // 标记这是分组结果
                    groups[key].__isGroup = true;
                }
            });
            
            return Object.values(groups);
        }
        
        // 投影数据
        function projectData(data, columns) {
            return data.map(row => {
                const newRow = {};
                columns.forEach(col => {
                    const colLower = col.toLowerCase();
                    if (col.includes('.')) {
                        const [table, column] = col.split('.');
                        if (row[column] !== undefined) {
                            newRow[column] = row[column];
                        }
                    } else if (colLower.includes('count(*)')) {
                        // 处理COUNT(*)
                        const asMatch = colLower.match(/count\(\*\)\s+as\s+(\w+)/i);
                        const alias = asMatch ? asMatch[1] : 'count';
                        // 使用之前计算的__count
                        newRow[alias] = row.__count !== undefined ? row.__count : 0;
                    } else if (colLower.includes('avg(')) {
                        // 处理AVG聚合函数
                        const avgMatch = colLower.match(/avg\((\w+)\)\s+as\s+(\w+)/i);
                        if (avgMatch) {
                            const avgColumn = avgMatch[1];
                            const alias = avgMatch[2];
                            newRow[alias] = calculateAvg(data, avgColumn, row);
                        }
                    } else if (row[col] !== undefined) {
                        newRow[col] = row[col];
                    }
                });
                return newRow;
            });
        }
        
        // 计算平均值
        function calculateAvg(data, column, groupRow) {
            if (groupRow.__isGroup) {
                const groupKey = Object.keys(groupRow)
                    .filter(key => !key.startsWith('__') && key !== column)
                    .map(key => groupRow[key])
                    .join('|');
                
                const groupItems = data.filter(row => {
                    return Object.keys(groupRow)
                        .filter(key => !key.startsWith('__') && key !== column)
                        .every(key => row[key] === groupRow[key]);
                });
                
                const sum = groupItems.reduce((acc, row) => acc + row[column], 0);
                return sum / groupItems.length;
            }
            
            const sum = data.reduce((acc, row) => acc + row[column], 0);
            return sum / data.length;
        }
        
        // 排序数据
        function orderData(data, columns) {
            return [...data].sort((a, b) => {
                for (const { column, direction } of columns) {
                    const valA = a[column];
                    const valB = b[column];
                    
                    if (valA < valB) return direction === 'asc' ? -1 : 1;
                    if (valA > valB) return direction === 'asc' ? 1 : -1;
                }
                return 0;
            });
        }
        
        // 显示当前步骤
        function updateStepDisplay() {
            steps.forEach((step, index) => {
                const element = document.getElementById(step);
                if (index === currentStep) {
                    element.classList.add('active');
                    updateStepContent(step);
                } else {
                    element.classList.remove('active');
                }
            });
        }
        
        // 更新步骤内容
        function updateStepContent(stepId) {
            const contentElement = document.getElementById(`${stepId}-content`);
            let content = '';
            
            switch (stepId) {
                case 'step-from':
                    content = `从 ${Object.keys(executionResults.from)[0]} 表读取数据:\n\n`;
                    content += formatData(executionResults.from);
                    break;
                    
                case 'step-join':
                    if (executionResults.join) {
                        content = `连接 ${executionResults.join.table} 表，条件: ${executionResults.join.condition}\n\n`;
                        content += formatData(executionResults.join.result);
                    } else {
                        content = '此查询没有JOIN操作';
                    }
                    break;
                    
                case 'step-where':
                    if (executionResults.where) {
                        content = `应用WHERE条件: ${executionResults.where.condition}\n\n`;
                        content += formatData(executionResults.where.result);
                    } else {
                        content = '此查询没有WHERE子句';
                    }
                    break;
                    
                case 'step-groupby':
                    if (executionResults.groupby) {
                        content = `按 ${executionResults.groupby.columns.join(', ')} 分组\n\n`;
                        content += formatData(executionResults.groupby.result);
                    } else {
                        content = '此查询没有GROUP BY子句';
                    }
                    break;
                    
                case 'step-having':
                    if (executionResults.having) {
                        content = `应用HAVING条件: ${executionResults.having.condition}\n\n`;
                        content += formatData(executionResults.having.result);
                    } else {
                        content = '此查询没有HAVING子句';
                    }
                    break;
                    
                case 'step-select':
                    if (executionResults.select) {
                        content = `选择列: ${executionResults.select.columns.join(', ')}\n\n`;
                        content += formatData(executionResults.select.result);
                    }
                    break;
                    
                case 'step-orderby':
                    if (executionResults.orderby) {
                        const orderStr = executionResults.orderby.columns.map(col => {
                            return `${col.column} ${col.direction}`;
                        }).join(', ');
                        content = `按 ${orderStr} 排序\n\n`;
                        content += formatData(executionResults.orderby.result);
                    } else {
                        content = '此查询没有ORDER BY子句';
                    }
                    break;
                    
                case 'step-limit':
                    if (executionResults.limit) {
                        content = `限制返回 TOP ${executionResults.limit.limit} 条记录\n\n`;
                        content += formatData(executionResults.limit.result);
                    } else {
                        content = '此查询没有TOP限制';
                    }
                    break;
            }
            
            contentElement.textContent = content;
        }
        
        // 格式化数据为字符串
        function formatData(data) {
            if (!data || data.length === 0) return '无数据';
            
            const sample = data.slice(0, 5);
            const columns = Object.keys(sample[0])
                .filter(col => !col.startsWith('__') || col === '__count'); // 包含__count属性
            
            // 替换__count为"记录数"
            const displayColumns = columns.map(col => col === '__count' ? '记录数' : col);
            
            let result = displayColumns.join('\t') + '\n';
            result += '-'.repeat(displayColumns.join('').length + (displayColumns.length - 1) * 3) + '\n';
            
            sample.forEach(row => {
                result += columns.map(col => row[col]).join('\t') + '\n';
            });
            
            if (data.length > 5) {
                result += `...还有 ${data.length - 5} 条记录未显示`;
            }
            
            return result;
        }
        
        // 上一步
        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                updateStepDisplay();
                document.getElementById('next-step').disabled = false;
                
                if (currentStep === 0) {
                    document.getElementById('prev-step').disabled = true;
                }
            }
        }
        
        // 下一步
        function nextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                updateStepDisplay();
                document.getElementById('prev-step').disabled = false;
                
                if (currentStep === steps.length - 1) {
                    document.getElementById('next-step').disabled = true;
                }
            }
        }
        
        // 加载示例SQL
        function loadSample(index) {
            const samples = [
                "SELECT TOP 10 name, age FROM Students WHERE age > 20 ORDER BY age DESC;",
                "SELECT s.name, c.title, g.grade FROM Students s JOIN Grade g ON s.sid = g.sid JOIN Courses c ON g.cid = c.cid WHERE g.grade > 85;",
                "SELECT major, AVG(age) as avg_age, COUNT(*) as count FROM Students GROUP BY major HAVING COUNT(*) > 1;"
            ];
            
            document.getElementById('sql-input').value = samples[index];
            parseSQL();
        }
        
        // 显示示例数据
        function showSampleData() {
            const container = document.getElementById('tables-container');
            container.innerHTML = '';
            
            for (const tableName in sampleDatabase) {
                const tableDiv = document.createElement('div');
                tableDiv.innerHTML = `<h4>${tableName}</h4>`;
                
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');
                
                // 表头
                const headerRow = document.createElement('tr');
                const columns = Object.keys(sampleDatabase[tableName][0]);
                columns.forEach(col => {
                    const th = document.createElement('th');
                    th.textContent = col;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                
                // 表数据
                sampleDatabase[tableName].slice(0, 3).forEach(row => {
                    const tr = document.createElement('tr');
                    columns.forEach(col => {
                        const td = document.createElement('td');
                        td.textContent = row[col];
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });
                
                if (sampleDatabase[tableName].length > 3) {
                    const tr = document.createElement('tr');
                    const td = document.createElement('td');
                    td.colSpan = columns.length;
                    td.textContent = `...还有 ${sampleDatabase[tableName].length - 3} 条记录`;
                    tr.appendChild(td);
                    tbody.appendChild(tr);
                }
                
                table.appendChild(thead);
                table.appendChild(tbody);
                tableDiv.appendChild(table);
                container.appendChild(tableDiv);
            }
        }
        
        // 初始化找茬游戏
        function initGame() {
            currentQuestion = 0;
            showQuestion();
        }
        
        // 显示当前问题
        function showQuestion() {
            const question = gameQuestions[currentQuestion];
            document.getElementById('game-question').textContent = question.question;
            document.getElementById('game-sql').textContent = question.sql;
            
            const optionsContainer = document.getElementById('game-options');
            optionsContainer.innerHTML = '';
            
            question.options.forEach((option, index) => {
                const optionElement = document.createElement('div');
                optionElement.className = 'game-option';
                optionElement.textContent = option;
                optionElement.dataset.index = index;
                optionElement.addEventListener('click', selectOption);
                optionsContainer.appendChild(optionElement);
            });
            
            document.getElementById('game-feedback').className = 'game-feedback';
            document.getElementById('game-feedback').textContent = '';
            document.getElementById('next-question').classList.remove('show');
            selectedOption = null;
        }
        
        // 选择选项
        function selectOption() {
            if (document.getElementById('game-feedback').classList.contains('correct') || 
                document.getElementById('game-feedback').classList.contains('incorrect')) {
                return;
            }
            
            document.querySelectorAll('.game-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            this.classList.add('selected');
            selectedOption = parseInt(this.dataset.index);
        }
        
        // 检查答案
        function checkAnswer() {
            if (selectedOption === null) {
                alert('请先选择一个答案');
                return;
            }
            
            const question = gameQuestions[currentQuestion];
            const feedback = document.getElementById('game-feedback');
            
            if (selectedOption === question.correct) {
                feedback.className = 'game-feedback correct';
                feedback.textContent = '✓ 正确! ' + question.feedback;
            } else {
                feedback.className = 'game-feedback incorrect';
                feedback.textContent = '✗ 错误! ' + question.feedback;
                
                // 高亮显示正确答案
                document.querySelectorAll('.game-option').forEach((opt, index) => {
                    if (index === question.correct) {
                        opt.classList.add('correct');
                    } else if (index === selectedOption) {
                        opt.classList.add('incorrect');
                    }
                });
            }
            
            document.getElementById('next-question').classList.add('show');
        }
        
        // 下一题
        function nextQuestion() {
            if (currentQuestion < gameQuestions.length - 1) {
                currentQuestion++;
                showQuestion();
            } else {
                alert('恭喜你完成了所有题目!');
                currentQuestion = 0;
                showQuestion();
            }
        }
    </script>
</body>
</html>